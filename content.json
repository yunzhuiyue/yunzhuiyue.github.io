{
	"meta": {
		"title": "Xiaoming's Blog",
		"subtitle": "IT 技术分享",
		"description": "白小明的博客，IT 技术分享",
		"author": "白小明",
		"url": "http://www.lovebxm.com"
	},
	"pages": [{
		"title": "",
		"date": "2017-05-31T07:50:58.967Z",
		"updated": "2017-05-31T07:50:58.967Z",
		"comments": true,
		"path": "404.html",
		"permalink": "http://www.lovebxm.com/404.html",
		"excerpt": "",
		"text": "Xiaoming's Blog | 404 html, body { height: 100%; min-height: 100%; background: #161B20; overflow: hidden } #block { width: 1px; height: 1px; font-size: 10px } #block:after { content: ''; position: absolute; top: 36%; left: 50%; width: 1em; height: 1em; -webkit-transform: translateX(-14em); transform: translateX(-14em) } @media screen and (max-width:320px) { #block:after { -webkit-transform: translateX(-11.5em) scale(.8); transform: translateX(-11.5em) scale(.8) } } .home { position: absolute; bottom: 10%; left: 50%; margin-left: -14px; text-decoration: none } .icon-home { position: relative; display: block; width: 30px; height: 30px; background: #484C4D } .icon-home:before { content: ''; position: absolute; width: 0; height: 0; top: -40px; left: -9px; border: 24px solid transparent; border-bottom-color: #484C4D } .icon-home:after { content: ''; position: absolute; height: 0; width: 0; top: 16px; left: 7px; width: 16px; height: 14px; background: #161B20 } !function() { function n() { return \"#\" + (\"00000\" + (16777215 * Math.random() + .5 >> 0).toString(16)).slice( - 6) } function e(e, t) { return e + \"em \" + t + \"em \" + n() } function t(n, e, t, u) { var r = document.getElementById(n); r || (r = document.createElement(\"style\"), r.id = n), r.innerHTML = e + \"{\" + t + \":\" + u + \";}\", document.getElementsByTagName(\"head\")[0].appendChild(r) } function u(n, t, u, r) { for (var o = [], s = 0, h = t - .5; n + u >= s; s++, h = t - .5 * (s + 1)) if (s === n) for (var i = h + .5; t + r >= i; i++) o.push(e(i, n)); else o.push(e(t, s)), n > s && o.push(e(h, s + .5)); return o.join(\",\") } function r(n, t, u) { for (var r = [], o = 0, s = 0; u > s; s++) r.push(e(n + s, 0)), r.push(e(n + s, t)); for (r.push(e(n - .5, o + .5)), r.push(e(n + u - 1 + .5, o + .5)), o = t - 1, r.push(e(n - .5, o + .5)), r.push(e(n + u - 1 + .5, o + .5)), s = 1; t > s; s++) r.push(e(n - 1, s)), r.push(e(n + u, s)); return r.join(\",\") } setInterval(function() { t(\"style\", \"#block:after\", \"box-shadow\", u(10, 5, 2, 1) + \",\" + r(12, 12, 5) + \",\" + u(10, 26, 2, 1)) }, 200) } ();"
	}, {
		"title": "",
		"date": "2017-05-31T07:07:24.575Z",
		"updated": "2017-05-31T07:03:12.184Z",
		"comments": true,
		"path": "README.html",
		"permalink": "http://www.lovebxm.com/README.html",
		"excerpt": "",
		"text": "介绍这是我的个人网站。里面有各种IT技术分享，欢迎大家访问。 你可以通过 👉 http://www.lovebxm.com/ 访问 IntroduceIt’s my personal website, and has different kinds of IT skills to learn.Welcome to visit my personal website! You can visit it via 👉 http://www.lovebxm.com/"
	}, {
		"title": "categories",
		"date": "2017-05-30T02:44:20.000Z",
		"updated": "2017-05-30T02:44:20.322Z",
		"comments": true,
		"path": "categories/index-1.html",
		"permalink": "http://www.lovebxm.com/categories/index-1.html",
		"excerpt": "",
		"text": ""
	}, {
		"title": "",
		"date": "2017-05-29T15:30:04.837Z",
		"updated": "2017-05-29T15:30:04.837Z",
		"comments": false,
		"path": "categories/index.html",
		"permalink": "http://www.lovebxm.com/categories/index.html",
		"excerpt": "",
		"text": ""
	}, {
		"title": "",
		"date": "2017-05-29T15:29:36.105Z",
		"updated": "2017-05-29T15:29:36.105Z",
		"comments": false,
		"path": "tags/index.html",
		"permalink": "http://www.lovebxm.com/tags/index.html",
		"excerpt": "",
		"text": ""
	}, {
		"title": "我的作品",
		"date": "2017-07-08T05:43:27.934Z",
		"updated": "2017-07-08T05:43:27.934Z",
		"comments": false,
		"path": "hand-peace-o/index.html",
		"permalink": "http://www.lovebxm.com/hand-peace-o/index.html",
		"excerpt": "",
		"text": "@timeline{ 索引@item{ 2016.10响应式理财网站以一个实际上线的金融网站为案例，学习响应式网页的成型过程 } @item{ 2017.4Vue.js 高仿饿了么外卖 APP使用 Vue.js + ES6 + webpack + Sass 等前端最新技术，完全高仿饿了么外卖 APP } @item{ 2017.6彩票项目（11选5）大量使用 ES6 原生语法，也是为了学习 ES6 而实战的项目 } } 响应式理财网站👉 GitHub: https://github.com/bxm0927/licaibao-responsive👉 项目演示地址: http://www.lovebxm.com/licaibao-responsive/src/项目简介这是一个响应式的理财网站，方法是CSS 媒体查询，可以适配电脑、平板、手机等多终端不同尺寸的设备。是以一个实际上线的互联网金融网站为案例，实际演示响应式网页的成型过程。收获1. 对常见的响应式布局方法（CSS Media Query、Flex弹性布局、Bootstrap栅格系统）有了更深的认识；2. 能够快速掌握一个简易JS插件（库）；3. 熟悉了Node.js的基本知识、包管理器npm的使用、httpserver的使用；4. 熟悉了自动化构建工具 Gulp 的基本流程。技术栈【HTML/CSS/JS】：实现基本的 HTML 结构；渐进增强 or 优雅降级，自己整理的 reset.css 来统一页面初始样式、相对单位rem、媒体查询、清除浮动等CSS技巧；使用了响应式轮播图插件 OwlCarousel2，以及解决了一些浏览器兼容性问题。【Node.js】：同步异步编程方式的区别，包管理器NPM的使用，package.json 如何配置，http-server 的使用等知识。【Gulp】：自动化构建工具，使用Gulp进行自动化打包发布。 Vue.js 高仿饿了么外卖 APP👉 GitHub: https://github.com/bxm0927/elelmeApp👉 项目演示地址: https://bxm0927.github.io/elelmeApp/dist/?id=123#/goods项目简介这是一个用 Vue.js 制作的高仿饿了么外卖的单页Web应用。使用 Vue.js + ES6 + webpack + Sass等前端最新最热的技术，采用组件化、模块化的开发方式。提取外卖App最核心的模块（商品、评论、商家），完全高仿饿了么外卖APP。收获1. 了解了一个项目完整的开发流程2. 学会了组件化、模块化的开发模式，将多次重复开发的样式抽象成 Vue 组件3. 学会使用 stylus、sass 预编译模块化的 CSS4. 学会前后端分离开发，mock 假的 json 后端数据存储在本地5. 掌握了使用 Vue-cli 脚手架初始化 Vue.js 项目6. 学会了使用 vue-router 将组件映射到路由，进行页面路由切换7. 学会了使用 vue-resource 进行 HTTP 请求获取数据8. 了解 webpack 的打包原理、学会 ES6 + eslint 的开发方式、学会如何在Vue.js框架里和第三方JS插件交互技术栈【HTML/CSS/JS】：localStorage、自己整理的 reset.css 来统一页面初始样式、移动端设备像素比、媒体查询、flex弹性布局、CSS Sticky footers、iconFont 图标字体等；通用 eslint 做 js 代码校验【Stylus】：预编译 CSS【better-scroll】：js 插件，实现平滑滚动效果【Vue.js】：一个前端 MVVM 框架，主要思想是双向数据绑定和组件化【vue-cli】：Vue.js 官方提供的一个脚手架工具，里面提供的一些基础的代码结构【vue-router】：用 Vue.js + vue-router 创建单页应用，是将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们【vue-resource】：这是一个 Vue.js 的插件，提供了使用 XMLHttpRequest 或 JSONP 进行Web请求和处理响应的服务【webpack】：打包 Vue.js 项目代码资源文件【Node.js】：使用 express 构建一个本地 HTTP server 来调试 Vue 项目 彩票项目（11选5）👉 GitHub: https://github.com/bxm0927/lottery👉 项目演示地址: http://es6lottery.t.imooc.io项目简介这一个彩票项目（11选5），大量使用 ES6 原生语法，也是为了学习 ES6 而实战的项目。本案例通过业务需求分析、项目架构思考、需求划分模块、前端代码编写、部署服务器端程序、前后端接口联调测试、部署上线几个步骤，真实还原实际业务开发流程。本项目主要功能模块：期号自动更新、倒计时、开售状态、玩法切换、自主选号、随机选号、金额计算、奖金预测等。收获1. 初步掌握了 ES62. 领悟了模块化编程的好处3. 加深对 gulp 自动化配置的掌握4. 了解了一个项目完整的开发流程技术栈【Sass(Scss)】: 预编译 CSS，方便快捷【ES6】: 这是以后的趋势，let、const、class、箭头函数、Set Map 数据结构、Promise 等新特性十分实用【Gulp】: 编写 gulp 脚本完成ES6的自动编译、打包、文件监听、浏览器热更新、模板自动更新、服务热启动等【Babel】: gulp 的一个插件，实现了 ES6 转 ES5【Webpack】: 自动编译【Express.js】: 搭建服务器【mockjs】: 模拟后端数据，与前端实现数据对接 未完待续……"
	}, {
		"title": "关于我",
		"date": "2017-07-08T05:49:44.111Z",
		"updated": "2017-07-08T05:49:44.111Z",
		"comments": false,
		"path": "user/index.html",
		"permalink": "http://www.lovebxm.com/user/index.html",
		"excerpt": "",
		"text": "HTML 版个人简历 / PDF 版个人简历姓名：白小明专业：软件工程微信：bxm_0927邮箱：80583600@qq.com扣扣：80583600 (开始聊天)GitHub：https://github.com/bxm0927个人简介：👉 专注于 Web前端 + Node.js 的探索者，目前是一个待业的大三程序猿，爱钻研，爱分享。目前技术栈：【前端】：HTML/HTML5、CSS/CSS3、SASS(SCSS)、JavaScript(ES5/ES6)、Ajax、JSON、jQuery、Bootstrap、Vue.js、微信公众号、微信小程序【后端】：Node.js、PHP【数据库】：MongoDB、MySQL、SQL Server【版本管理】：Git + GitHub【自动化构建】：Webpack、Gulp、Grunt"
	}],
	"posts": [{
		"title": "Web 前端代码规范",
		"slug": "web-code-standards",
		"date": "2017-06-25T08:23:05.197Z",
		"updated": "2017-06-25T08:24:14.552Z",
		"comments": true,
		"path": "2017/06/25/web-code-standards/",
		"link": "",
		"permalink": "http://www.lovebxm.com/2017/06/25/web-code-standards/",
		"excerpt": "Web 前端代码规范最后更新时间：2017-06-25 原始文章链接：https://github.com/bxm0927/web-code-standards 此项目用于记录规范的、高可维护性的前端代码，这是通过分析 Github 众多前端代码库，总结出来的前端代码书写规范。",
		"text": "Web 前端代码规范最后更新时间：2017-06-25 原始文章链接：https://github.com/bxm0927/web-code-standards 此项目用于记录规范的、高可维护性的前端代码，这是通过分析 Github 众多前端代码库，总结出来的前端代码书写规范。 目录 前端普适性规范 HTML 规范 CSS 规范 JS 规范 Licensepublic domain, Just take it. Thanks@Ruan YiFeng: https://github.com/ruanyf @materliu：https://materliu.github.io/code-guide @hzlzh: https://github.com/hzlzh/Front-End-Standards @tguide: http://tguide.qq.com/main/base.htm 前端普适性规范黄金定律永远遵循同一套编码规范，可以是这里列出的，也可以是你自己总结的。如果你发现本规范中有任何错误，敬请指正。 不管有多少人共同参与同一项目，一定要确保每一行代码都像是同一个人编写的。 项目命名项目名全部采用小写方式，以中划线分隔，禁止驼峰式命名。比如：my-project-name 文件命名文件命名参照上一条规则，多个单词组成时，采用中划线连接方式，比如说: error-report.html 有复数结构时，要采用复数命名法，比如说： scripts, styles, images, data-models 文件名中只可由小写英文字母a~z、排序数字0~9或间隔符-组成，禁止包含特殊符号，比如空格、$等 为更好的表达语义，文件名使用英文名词命名，或英文简写。 不允许命名带有广告等英文的单词，例如ad,adv,adver,advertising，防止该模块被浏览器当成垃圾广告过滤掉。任何文件的命名均如此。 index.shtml 引导页&amp;首页 main.shtml 首页 download.shtml 下载页面 act.html 活动列表页面 video.html 视频 cdkey.html CDKEY页面 base.css 基本样式 layout.css 框架布局 module.css 模块样式 global.css 全局样式 font.css 字体样式 index.css 首页样式 link.css 链接样式 print.css 打印样式 HTML 规范语法使用四个空格的缩进，这是保证代码在各种环境下显示一致的唯一方式。 嵌套的节点应该缩进（四个空格）。 在属性上，使用双引号，不要使用单引号。 不要在自动闭合标签结尾处使用斜线 - HTML5 规范 指出他们是可选的。 不要忽略可选的关闭标签（例如， 和 ）。 1&lt;img src=&quot;images/logo.png&quot; alt=&quot;Company&quot;&gt; HTML5 doctype在每个 HTML 页面开头使用这个简单地 doctype 来启用标准模式，使其每个浏览器中尽可能一致的展现。 虽然doctype不区分大小写，但是按照惯例，doctype大写 1&lt;!DOCTYPE html&gt; 语言属性123&lt;html lang=&quot;en&quot;&gt;&lt;/html&gt; 字符编码通过明确声明字符编码，能够确保浏览器快速并容易的判断页面内容的渲染方式。这样做的好处是，可以避免在 HTML 中使用字符实体标记（character entity），从而全部与文档编码一致（一般采用 UTF-8 编码）。 1&lt;meta charset=&quot;UTF-8&quot;&gt; IE 兼容模式IE 支持通过特定的 标签来确定绘制当前页面所应该采用的 IE 版本。除非有强烈的特殊需求，否则最好是设置为 edge mode，从而通知 IE 采用其所支持的最新的模式。 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; 响应式1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 引入 CSS 和 JavaScript根据 HTML5 规范, 通常在引入 CSS 和 JavaScript 时不需要指明 type，因为 text/css 和 text/javascript 分别是他们的默认值。 12345678910&lt;!-- External CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;code-guide.css&quot;&gt;&lt;!-- In-document CSS --&gt;&lt;style&gt; /* ... */&lt;/style&gt;&lt;!-- JavaScript --&gt;&lt;script src=&quot;code-guide.js&quot;&gt;&lt;/script&gt; 实用高于完美尽量遵循 HTML 标准和语义，但是不应该以浪费实用性作为代价。任何时候都要用尽量小的复杂度和尽量少的标签来解决问题。 减少标签数量在编写 HTML 代码时，需要尽量避免多余的父节点。很多时候，需要通过迭代和重构来使 HTML 变得更少。 参考下面的示例: 1234567&lt;!-- Not so great --&gt;&lt;span class=&quot;avatar&quot;&gt; &lt;img src=&quot;...&quot;&gt;&lt;/span&gt;&lt;!-- Better --&gt;&lt;img class=&quot;avatar&quot; src=&quot;...&quot;&gt; 属性顺序HTML 属性应该按照特定的顺序出现以保证易读性。 class id name data-* src, for, type, href, value , max-length, max, min, pattern placeholder, title, alt aria-*, role required, readonly, disabled class 是为高可复用组件设计的，理论上他们应处在第一位。id 更加具体而且应该尽量少使用（例如, 页内书签），所以他们处在第二位。 Boolean 属性Boolean 属性指不需要声明取值的属性。XHTML 需要每个属性声明取值，但是 HTML5 并不需要。 一个元素中 Boolean 属性的存在表示取值 true，不存在则表示取值 false。 简而言之，不要为 Boolean 属性添加取值。 1&lt;input type=&quot;text&quot; disabled&gt; JavaScript 生成标签在 JavaScript 文件中生成标签让内容变得更难查找，更难编辑，性能更差。应该尽量避免这种情况的出现。 CSS 规范语法使用四个空格的缩进，这是保证代码在各种环境下显示一致的唯一方式。 使用组合选择器时，保持每个独立的选择器占用一行。 为了代码的易读性，在每个声明的左括号前增加一个空格。 声明块的右括号应该另起一行。 每条声明 : 后应该插入一个空格。 每条声明应该只占用一行来保证错误报告更加准确。 所有声明应该以分号结尾。虽然最后一条声明后的分号是可选的，但是如果没有他，你的代码会更容易出错。 逗号分隔的取值，都应该在逗号之后增加一个空格。 不要在颜色值 rgb() rgba() hsl() hsla()和 rect() 中增加空格，并且不要带有取值前面不必要的 0 (比如，使用 .5 替代 0.5)。 所有的十六进制值都应该使用小写字母，例如 #fff。因为小写字母有更多样的外形，在浏览文档时，他们能够更轻松的被区分开来。 尽可能使用短的十六进制数值，例如使用 #fff 替代 #ffffff。 为选择器中的属性取值添加引号，例如 input[type=”text”]。 他们只在某些情况下可有可无，所以都使用引号可以增加一致性。 不要为 0 指明单位，比如使用 margin: 0; 而不是 margin: 0px;。 123456789101112131415/* Bad CSS */.selector, .selector-secondary, .selector[type=text] &#123; margin: 0px 0px 15px; background-color: rgba(0, 0, 0, 0.5); box-shadow: 0 1px 2px #CCC, inset 0 1px 0 #FFFFFF&#125;/* Good CSS */.selector,.selector-secondary,.selector[type=&quot;text&quot;] &#123; margin-bottom: 15px; background-color: rgba(0,0,0,.5); box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;&#125; 声明顺序相关的属性声明应该以下面的顺序分组处理： Positioning Box model 盒模型 Typographic 排版 Visual 外观 Positioning 处在第一位，因为他可以使一个元素脱离正常文本流，并且覆盖盒模型相关的样式。盒模型紧跟其后，因为他决定了一个组件的大小和位置。 其他属性只在组件内部起作用或者不会对前面两种情况的结果产生影响，所以他们排在后面。 1234567891011121314151617181920212223242526272829.declaration-order &#123; /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Box-model */ display: block; float: right; width: 100px; height: 100px; /* Typography */ font: normal 13px &quot;Helvetica Neue&quot;, sans-serif; line-height: 1.5; color: #333; text-align: center; /* Visual */ background-color: #f5f5f5; border: 1px solid #e5e5e5; border-radius: 3px; /* Misc */ opacity: 1;&#125; Don’t use @import与&lt;link&gt;相比，@import较慢，增加额外的页面请求，并可能导致其他不可预见的问题。 1234567&lt;!-- Use link elements --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;core.css&quot;&gt;&lt;!-- Avoid @imports --&gt;&lt;style&gt; @import url(&quot;more.css&quot;);&lt;/style&gt; 媒体查询位置尽量将媒体查询的位置靠近他们相关的规则。不要将他们一起放到一个独立的样式文件中，或者丢在文档的最底部。这样做只会让大家以后更容易忘记他们。这里是一个典型的案例。 123456789.element &#123; ... &#125;.element-avatar &#123; ... &#125;.element-selected &#123; ... &#125;@media (min-width: 480px) &#123; .element &#123; ...&#125; .element-avatar &#123; ... &#125; .element-selected &#123; ... &#125;&#125; 前缀属性当使用厂商前缀属性时，通过缩进使取值垂直对齐以便多行编辑。 12345/* Prefixed properties */.selector &#123; -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15); box-shadow: 0 1px 2px rgba(0,0,0,.15);&#125; 单条声明的声明块在一个声明块中只包含一条声明的情况下，为了易读性和快速编辑可以考虑移除其中的换行。所有包含多条声明的声明块应该分为多行。 这样做的关键因素是错误检测 - 例如，一个 CSS 验证程序显示你在 183 行有一个语法错误,如果是一个单条声明的行，那就是他了。在多个声明的情况下，你必须为哪里出错了费下脑子。 123.span1 &#123; width: 60px; &#125;.span2 &#123; width: 140px; &#125;.span3 &#123; width: 220px; &#125; 属性简写尽量不使用属性简写的方式，属性简写需要你必须显式设置所有取值。常见的属性简写滥用包括: padding margin font background-border-border-radius 大多数情况下，我们并不需要设置属性简写中包含的所有值。例如，HTML 头部只设置上下的 margin，所以如果需要，只设置这两个值。过度使用属性简写往往会导致更混乱的代码，其中包含不必要的重写和意想不到的副作用。 12345678910111213141516/* Bad example */.element &#123; margin: 0 0 10px; background: red; background: url(&quot;image.jpg&quot;); border-radius: 3px 3px 0 0;&#125;/* Good example */.element &#123; margin-bottom: 10px; background-color: red; background-image: url(&quot;image.jpg&quot;); border-top-left-radius: 3px; border-top-right-radius: 3px;&#125; Less 和 Sass 中的嵌套避免不必要的嵌套。可以进行嵌套，不意味着你应该这样做。只有在需要给父元素增加样式并且同时存在多个子元素时才需要考虑嵌套。 123456789// Without nesting.table &gt; thead &gt; tr &gt; th &#123; … &#125;.table &gt; thead &gt; tr &gt; td &#123; … &#125;// With nesting.table &gt; thead &gt; tr &#123; &gt; th &#123; … &#125; &gt; td &#123; … &#125;&#125; 代码注释代码是由人来编写和维护的。保证你的代码是描述性的，包含好的注释，并且容易被他人理解。好的代码注释传达上下文和目标。不要简单地重申组件或者 class 名称。 class 命名保持 class 命名为全小写，可以使用短划线（不要使用下划线和 camelCase 命名）。短划线应该作为相关类的自然间断。(例如，.btn 和 .btn-danger)。 避免过度使用简写。.btn 可以很好地描述 button，但是 .s 不能代表任何元素。 class 的命名应该尽量短，也要尽量明确。 使用有意义的名称；使用结构化或者作用目标相关，而不是抽象的名称。 命名时使用最近的父节点或者父 class 作为前缀。 使用 .js-* 来表示行为(相对于样式)，但是不要在 CSS 中包含这些 class。 选择器使用 class 而不是通用元素标签来优化渲染性能。 避免在经常出现的组件中使用一些属性选择器 (例如，[class^=”…”])。浏览器性能会受到这些情况的影响。 减少选择器的长度，每个组合选择器选择器的条目应该尽量控制在 3 个以内。 只在必要的情况下使用后代选择器 (例如，没有使用带前缀 classes 的情况). 代码组织以组件为单位组织代码。 制定一个一致的注释层级结构。 使用一致的空白来分割代码块，这样做在查看大的文档时更有优势。 当使用多个 CSS 文件时，通过组件而不是页面来区分他们。页面会被重新排列，而组件移动就可以了。 编辑器配置根据以下的设置来配置你的编辑器，将这些设置应用到项目的 .editorconfig 文件，来避免常见的代码不一致和丑陋的 diffs。 使用四个空格的缩进。 在保存时删除尾部的空白字符。 设置文件编码为 UTF-8。 在文件结尾添加一个空白行。 JS 规范语法使用四个空格的缩进，这是保证代码在各种环境下显示一致的唯一方式。 声明之后一律以分号结束， 不可以省略 完全避免 == != 的使用， 用严格比较条件 === !== eval 非特殊情况， 禁用！！！ with 非特殊情况， 禁用！！！ 单行长度，理论上不要超过80列，不过如果编辑器开启”自动换行”的话可以不考虑单行长度 接上一条，如果需要换行，存在操作符的情况，一定在操作符后换行，然后换的行缩进4个空格 这里要注意，如果是多次换行的话就没有必要继续缩进了，比如说下面这种就是最佳格式。 1234567if (typeof qqfind === &quot;undefined&quot; || typeof qqfind.cdnrejected === &quot;undefined&quot; || qqfind.cdnrejected !== true) &#123; url = &quot;http://pub.idqqimg.com/qqfind/js/location4.js&quot;;&#125; else &#123; url = &quot;http://find.qq.com/js/location4.js&quot;;&#125; 空行方法之间加 单行或多行注释前加 逻辑块之间加空行增加可读性 变量命名标准变量采用驼峰标识 使用的ID的地方一定全大写 使用的URL的地方一定全大写, 比如说 reportURL 涉及Android的，一律大写第一个字母 涉及iOS的，一律小写第一个，大写后两个字母 常量采用大写字母，下划线连接的方式 构造函数，大写第一个字母 12345678910111213var thisIsMyName;var goodID;var AndroidVersion;var iOSVersion;var MAX_COUNT = 10;function Person(name) &#123; this.name = name&#125; 字符常量一般情况下统一使用单引号 null的使用场景初始化可能以后分配对象值的变量 与一个可能或可能没有对象值的初始化变量进行比较 传入一个预期对象的函数 从预期对象的函数返回 不适合null的使用场景不要使用null来测试是否提供参数 不要测试值为null的未初始化变量 undefined使用场景永远不要直接使用undefined进行变量判断 使用字符串 “undefined” 对变量进行判断 123456// Badvar person;console.log(person === undefined); //true// Goodconsole.log(typeof person); // &quot;undefined&quot; 对象字面量12345678910// Badvar team = new Team();team.title = &quot;AlloyTeam&quot;;team.count = 25;// Goodvar team = &#123; title: &quot;AlloyTeam&quot;, count: 25&#125;; 数组声明12345678// Badvar colors = new Array(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;);var numbers = new Array(1, 2, 3, 4);// Goodvar colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];var numbers = [ 1, 2, 3, 4 ]; 单行注释双斜线后，必须跟注释内容保留一个空格 与下一行代码缩进保持一致 可位于一个代码行的末尾，双斜线距离分号四个空格 1234567// Goodif (condition) &#123; // if you made it here, then all security checks passed allowed();&#125;var zhangsan = &quot;zhangsan&quot;; // 双斜线距离分号四个空格，双斜线后始终保留一个空格 多行注释格式最少三行 前边留空一行 123/** * 注释内容与星标前保留一个空格 */ 何时使用多行注释格式难于理解的代码段 可能存在错误的代码段 浏览器特殊的HACK代码 业务逻辑强相关的代码 想吐槽的产品逻辑, 合作同事 文档注释各类标签 @param @method 等 参考 http://usejsdoc.org/ 用于：方法、构造函数、对象 123456/** * here boy, look here , here is girl * @method lookGril * @param &#123;Object&#125; balabalabala * @return &#123;Object&#125; balabalabala */ 括号对齐标准示例 括号前后有空格，花括号起始不另换行，结尾新起一行 花括号必须要，即使内容只有一行 涉及 if for while do…while try…catch…finally 的地方都必须使用花括号，即使内容只有一行 if else 前后留有空格12345if (condition) &#123; doSomething();&#125; else &#123; doSomethingElse();&#125; switchswitch和括号之间有空格，case需要缩进，break之后跟下一个case中间留一个空白行 花括号必须要， 即使内容只有一行。 switch 的 falling through 一定要有注释特别说明，no default 的情况也需要注释特别说明况 123456789101112switch (condition) &#123; case &quot;first&quot;: // code break; case &quot;second&quot;: // code break; default: // code&#125; for普通for循环, 分号后留有一个空格， 判断条件等内的操作符两边不留空格 前置条件如果有多个，逗号后留一个空格 for-in 一定要有 hasOwnProperty 的判断， 否则 JSLint 或者 JSHint 都会有一个 warn 1234567891011121314for (i=0, len=values.length; i&lt;len; i++) &#123; process(values[i]);&#125;var prop;for (prop in object) &#123; // 注意这里一定要有 hasOwnProperty 的判断， 否则 JSLint 或者 JSHint 都会有一个 warn ！ if (object.hasOwnProperty(prop)) &#123; console.log(&quot;Property name is &quot; + prop); console.log(&quot;Property value is &quot; + object[prop]); &#125;&#125; 变量声明所有函数内变量声明放在函数内头部，只使用一个 var(多了JSLint报错)， 一个变量一行， 在行末跟注释， 注释啊，注释啊，亲 函数声明一定先声明再使用， 不要利用 JavaScript engine的变量提升特性, 违反了这个规则 JSLint 和 JSHint都会报 warn function declaration 和 function expression 的不同，function expression 的（）前后必须有空格，而function declaration 在有函数名的时候不需要空格，没有函数名的时候需要空格。 函数调用括号前后不需要空格 立即执行函数的写法, 最外层必须包一层括号 “use strict” 决不允许全局使用， 必须放在函数的第一行， 可以用自执行函数包含大的代码段, 如果 “use strict” 在函数外使用， JSLint 和 JSHint 均会报错 1234567891011121314151617181920212223function doSomething(item) &#123; // do something&#125;var doSomething = function (item) &#123; // do something&#125;// GooddoSomething(item);// Bad: Looks like a block statementdoSomething (item);// Good(function() &#123; &quot;use strict&quot;; function doSomething() &#123; // code &#125;&#125;)();",
		"categories": [],
		"tags": [{
			"name": "js",
			"slug": "js",
			"permalink": "http://www.lovebxm.com/tags/js/"
		}, {
			"name": "html",
			"slug": "html",
			"permalink": "http://www.lovebxm.com/tags/html/"
		}, {
			"name": "css",
			"slug": "css",
			"permalink": "http://www.lovebxm.com/tags/css/"
		}]
	}, {
		"title": "学习 ES6，一篇文章就够了",
		"slug": "es6_study",
		"date": "2017-06-24T10:51:10.191Z",
		"updated": "2017-06-24T10:52:48.965Z",
		"comments": true,
		"path": "2017/06/24/es6_study/",
		"link": "",
		"permalink": "http://www.lovebxm.com/2017/06/24/es6_study/",
		"excerpt": "ES6 简介ECMAScript 6 简称 ES6，是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 ECMAScript 和 JavaScript 的关系：前者是后者的语法规格，后者是前者的一种实现 Babel：将ES6代码转为ES5代码 http://babeljs.io/ image",
		"text": "ES6 简介ECMAScript 6 简称 ES6，是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 ECMAScript 和 JavaScript 的关系：前者是后者的语法规格，后者是前者的一种实现 Babel：将ES6代码转为ES5代码 http://babeljs.io/ image 新特性let、constlet 定义的变量不会被变量提升，const 定义的常量不能被修改，let 和 const 都是块级作用域 ES6前，js 是没有块级作用域 {} 的概念的。（有函数作用域、全局作用域、eval作用域） ES6后，let 和 const 的出现，js 也有了块级作用域的概念，前端的知识是日新月异的~ 变量提升：在ES6以前，var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部；不在函数内即在全局作用域的最顶部。这样就会引起一些误解。例如： 1234567891011console.log(a); // undefinedvar a = &apos;hello&apos;;# 上面的代码相当于var a;console.log(a);a = &apos;hello&apos;;# 而 let 就不会被变量提升console.log(a); // a is not definedlet a = &apos;hello&apos;; const 定义的常量不能被修改 12345678var name = &quot;bai&quot;;name = &quot;ming&quot;;console.log(name); // mingconst name = &quot;bai&quot;;name = &quot;ming&quot;; // Assignment to constant variable.console.log(name); import、exportimport导入模块、export导出模块 1234567891011121314151617// 全部导入import people from &apos;./example&apos;// 将整个模块当作单一对象进行导入，该模块的所有导出都会作为对象的属性存在import * as example from &quot;./example.js&quot;console.log(example.name)console.log(example.getName())// 导入部分，引入非 default 时，使用花括号import &#123;name, age&#125; from &apos;./example&apos;// 导出默认, 有且只有一个默认export default App// 部分导出export class App extend Component &#123;&#125;; class、extends、superES5中最令人头疼的的几个部分：原型、构造函数，继承，有了ES6我们不再烦恼！ ES6引入了Class（类）这个概念。 123456789101112131415161718192021class Animal &#123; constructor() &#123; this.type = &apos;animal&apos;; &#125; says(say) &#123; console.log(this.type + &apos; says &apos; + say); &#125;&#125;let animal = new Animal();animal.says(&apos;hello&apos;); //animal says helloclass Cat extends Animal &#123; constructor() &#123; super(); this.type = &apos;cat&apos;; &#125;&#125;let cat = new Cat();cat.says(&apos;hello&apos;); //cat says hello 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实力对象可以共享的。 Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。 super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ES5var Shape = function(id, x, y) &#123; this.id = id, this.move(x, y);&#125;;Shape.prototype.move = function(x, y) &#123; this.x = x; this.y = y;&#125;;var Rectangle = function id(ix, x, y, width, height) &#123; Shape.call(this, id, x, y); this.width = width; this.height = height;&#125;;Rectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle;var Circle = function(id, x, y, radius) &#123; Shape.call(this, id, x, y); this.radius = radius;&#125;;Circle.prototype = Object.create(Shape.prototype);Circle.prototype.constructor = Circle;// ES6class Shape &#123; constructor(id, x, y) &#123; this.id = id this.move(x, y); &#125; move(x, y) &#123; this.x = x this.y = y; &#125;&#125;class Rectangle extends Shape &#123; constructor(id, x, y, width, height) &#123; super(id, x, y) this.width = width this.height = height; &#125;&#125;class Circle extends Shape &#123; constructor(id, x, y, radius) &#123; super(id, x, y) this.radius = radius; &#125;&#125; arrow functions （箭头函数）函数的快捷写法。不需要 function 关键字来创建函数，省略 return 关键字，继承当前上下文的 this 关键字 1234567891011// ES5var arr1 = [1, 2, 3];var newArr1 = arr1.map(function(x) &#123; return x + 1;&#125;);// ES6let arr2 = [1, 2, 3];let newArr2 = arr2.map((x) =&gt; &#123; x + 1&#125;); 箭头函数小细节：当你的函数有且仅有一个参数的时候，是可以省略掉括号的；当你函数中有且仅有一个表达式的时候可以省略{} 12let arr2 = [1, 2, 3];let newArr2 = arr2.map(x =&gt; x + 1); JavaScript语言的this对象一直是一个令人头痛的问题，运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。 12345678910111213class Animal &#123; constructor() &#123; this.type = &apos;animal&apos;; &#125; says(say) &#123; setTimeout(function() &#123; console.log(this.type + &apos; says &apos; + say); &#125;, 1000); &#125;&#125;var animal = new Animal();animal.says(&apos;hi&apos;); //undefined says hi 解决办法： 12345678910111213141516171819202122// 传统方法1: 将this传给self,再用self来指代thissays(say) &#123; var self = this; setTimeout(function() &#123; console.log(self.type + &apos; says &apos; + say); &#125;, 1000);&#125;// 传统方法2: 用bind(this),即says(say) &#123; setTimeout(function() &#123; console.log(this.type + &apos; says &apos; + say); &#125;.bind(this), 1000);&#125;// ES6: 箭头函数// 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象says(say) &#123; setTimeout(() =&gt; &#123; console.log(this.type + &apos; says &apos; + say); &#125;, 1000);&#125; template string （模板字符串）解决了 ES5 在字符串功能上的痛点。 第一个用途：字符串拼接。将表达式嵌入字符串中进行拼接，用 ` 和${}`来界定。 1234567// es5var name1 = &quot;bai&quot;;console.log(&apos;hello&apos; + name1);// es6const name2 = &quot;ming&quot;;console.log(`hello$&#123;name2&#125;`); 第二个用途：在ES5时我们通过反斜杠来做多行字符串拼接。ES6反引号 `` 直接搞定。 12345678// es5var msg = &quot;Hi \\man!&quot;;// es6const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;`; 另外：includes repeat 1234567// includes：判断是否包含然后直接返回布尔值let str = &apos;hahah&apos;;console.log(str.includes(&apos;y&apos;)); // false// repeat: 获取字符串重复n次let s = &apos;he&apos;;console.log(s.repeat(3)); // &apos;hehehe&apos; destructuring （解构）简化数组和对象中信息的提取。 ES6前，我们一个一个获取对象信息； ES6后，解构能让我们从对象或者数组里取出数据存为变量 12345678910111213141516171819202122// ES5var people1 = &#123; name: &apos;bai&apos;, age: 20, color: [&apos;red&apos;, &apos;blue&apos;]&#125;;var myName = people1.name;var myAge = people1.age;var myColor = people1.color[0];console.log(myName + &apos;----&apos; + myAge + &apos;----&apos; + myColor);// ES6let people2 = &#123; name: &apos;ming&apos;, age: 20, color: [&apos;red&apos;, &apos;blue&apos;]&#125;let &#123; name, age &#125; = people2;let [first, second] = people2.color;console.log(`$&#123;name&#125;----$&#123;age&#125;----$&#123;first&#125;`); default 函数默认参数12345678910// ES5 给函数定义参数默认值function foo(num) &#123; num = num || 200; return num;&#125;// ES6function foo(num = 200) &#123; return num;&#125; rest arguments （rest参数）解决了 es5 复杂的 arguments 问题 1234function foo(x, y, ...rest) &#123; return ((x + y) * rest.length);&#125;foo(1, 2, &apos;hello&apos;, true, 7); // 9 Spread Operator （展开运算符）第一个用途：组装数组 123let color = [&apos;red&apos;, &apos;yellow&apos;];let colorful = [...color, &apos;green&apos;, &apos;blue&apos;];console.log(colorful); // [&quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;] 第二个用途：获取数组除了某几项的其他项 123let num = [1, 3, 5, 7, 9];let [first, second, ...rest] = num;console.log(rest); // [5, 7, 9] 对象对象初始化简写 123456789101112131415// ES5function people(name, age) &#123; return &#123; name: name, age: age &#125;;&#125;// ES6function people(name, age) &#123; return &#123; name, age &#125;;&#125; 对象字面量简写（省略冒号与 function 关键字） 123456789101112131415// ES5var people1 = &#123; name: &apos;bai&apos;, getName: function () &#123; console.log(this.name); &#125;&#125;;// ES6let people2 = &#123; name: &apos;bai&apos;, getName () &#123; console.log(this.name); &#125;&#125;; 另外：Object.assign() ES6 对象提供了Object.assign()这个方法来实现浅复制。Object.assign()可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{} 1234const obj = Object.assign(&#123;&#125;, objA, objB)// 给对象添加属性this.seller = Object.assign(&#123;&#125;, this.seller, response.data) Promise用同步的方式去写异步代码 123456789// 发起异步请求fetch(&apos;/api/todos&apos;) .then(res =&gt; res.json()) .then(data =&gt; (&#123; data &#125;)) .catch(err =&gt; (&#123; err &#125;)); Generators生成器（ generator）是能返回一个迭代器的函数。 生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。 这里生活中有一个比较形象的例子。咱们到银行办理业务时候都得向大厅的机器取一张排队号。你拿到你的排队号，机器并不会自动为你再出下一张票。也就是说取票机“暂停”住了，直到下一个人再次唤起才会继续吐票。 迭代器：当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。 12345678910111213// 生成器function *createIterator() &#123; yield 1; yield 2; yield 3;&#125;// 生成器能像正规函数那样被调用，但会返回一个迭代器let iterator = createIterator();console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3 迭代器对异步编程作用很大，异步调用对于我们来说是很困难的事，我们的函数并不会等待异步调用完再执行，你可能会想到用回调函数，（当然还有其他方案比如Promise比如Async/await）。 生成器可以让我们的代码进行等待。就不用嵌套的回调函数。使用generator可以确保当异步调用在我们的generator函数运行一下行代码之前完成时暂停函数的执行。 那么问题来了，咱们也不能手动一直调用next()方法，你需要一个能够调用生成器并启动迭代器的方法。就像这样子的： 1234567891011121314151617181920function run(taskDef) &#123; // taskDef 即一个生成器函数 // 创建迭代器，让它在别处可用 let task = taskDef(); // 启动任务 let result = task.next(); // 递归使用函数来保持对 next() 的调用 function step() &#123; // 如果还有更多要做的 if (!result.done) &#123; result = task.next(); step(); &#125; &#125; // 开始处理过程 step();&#125; 总结以上就是 ES6 最常用的一些语法，可以说这20%的语法，在ES6的日常使用中占了80%",
		"categories": [],
		"tags": [{
			"name": "JavaScript",
			"slug": "JavaScript",
			"permalink": "http://www.lovebxm.com/tags/JavaScript/"
		}, {
			"name": "js",
			"slug": "js",
			"permalink": "http://www.lovebxm.com/tags/js/"
		}, {
			"name": "ECMAScript 6",
			"slug": "ECMAScript-6",
			"permalink": "http://www.lovebxm.com/tags/ECMAScript-6/"
		}, {
			"name": "es6",
			"slug": "es6",
			"permalink": "http://www.lovebxm.com/tags/es6/"
		}]
	}, {
		"title": "最全正则表达式总结：验证QQ号、手机号、Email、中文、邮编、身份证、IP地址等",
		"slug": "RegExp",
		"date": "2017-05-31T03:30:24.194Z",
		"updated": "2017-05-31T03:36:01.918Z",
		"comments": true,
		"path": "2017/05/31/RegExp/",
		"link": "",
		"permalink": "http://www.lovebxm.com/2017/05/31/RegExp/",
		"excerpt": "什么是 RegExp？ RegExp 是正则表达式（Regular expression）的缩写，作用是对字符串执行模式匹配。 通常用于格式验证、正则替换、查找子串等 各种编程语言的正则表达式基本相同，不同的语言可能会有一些细小的差别",
		"text": "什么是 RegExp？ RegExp 是正则表达式（Regular expression）的缩写，作用是对字符串执行模式匹配。 通常用于格式验证、正则替换、查找子串等 各种编程语言的正则表达式基本相同，不同的语言可能会有一些细小的差别 RegExp入门：http://www.w3school.com.cn/js/js_obj_regexp.asp 完整的 RegExp 对象参考手册：http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp PHP 正则表达式：http://www.imooc.com/learn/350 javascript 正则表达式：http://www.imooc.com/learn/706 Python 正则表达式：http://www.imooc.com/learn/550 RegExp 语法12345// 直接实例化var reg = new RegExp(pattern [, flags]);// 隐式创建(推荐)var reg = /pattern/flags; 参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。 参数 [, flags] 是一个可选的字符串，包含属性 “g”（global ）、”i” （ignoreCase）和 “m”（multiline）。 ECMAScript 标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则必须省略该参数。 概念：子表达式在正则表达式中，使用括号括起来的内容是一个子表达式，子表达式匹配到的内容会被系统捕获至缓冲区，使用\\n（n：数字）来反向引用系统的第n号缓冲区的内容。 场景：后面的内容要求与前面的一致，可以使用子表达式 12345// 查找连续相同的四个数字var str = \"1212ab45677778cd\";var reg = /(\\d)\\1\\1\\1/gi;console.log(str.match(reg));// OUTPUT:7777 概念：方括号（字符簇）1234var str = \"Is this all there is?\";var patt1 = /[a-h]/g;document.write(str.match(patt1));// OUTPUT:h,a,h,e,e 方括号 作用 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。同 \\d [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [0-9a-zA-Z] 查找0-9,a-z,A-Z 概念：元字符元字符（Metacharacter）是拥有特殊含义的字符：元字符 | 作用—|—\\ | 转义符 （、）、/、\\| | 选择匹配符，可以匹配多个规则. | 查找单个字符，除了换行和行结束符。\\w | 查找单词字符。字符 ( 字母 ，数字，下划线_ )\\W | 查找非单词字符。\\d | 查找数字。\\D | 查找非数字字符。\\s | 查找空白字符。空格\\S | 查找非空白字符。\\b | 匹配单词边界。\\B | 匹配非单词边界。\\0 | 查找 NUL 字符。\\n | 查找换行符。\\f | 查找换页符。\\r | 查找回车符。\\t | 查找制表符。\\v | 查找垂直制表符。\\xxx | 查找以八进制数 xxx 规定的字符。\\xdd | 查找以十六进制数 dd 规定的字符。\\uxxxx | 查找以十六进制数 xxxx 规定的 Unicode 字符。 概念：量词 量词 作用 n+ 匹配任何包含至少一个 n 的字符串。同 {1,} n* 匹配任何包含零个或多个 n 的字符串。同 {0,} n? 匹配任何包含零个或一个 n 的字符串。同 {0,1} n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。注意 /[^a] / 和 /^ [a]/是不一样的，前者是排除的，后者是代表首位。 (?=n) 匹配任何其后紧接指定字符串 n 的字符串。正向预查 (?!n) 匹配任何其后没有紧接指定字符串 n 的字符串。反向预查 RegExp 对象方法test()test() 方法检索字符串中是否存在指定的值。返回值是 true 或 false。 1234567var patt1 = new RegExp('e');console.log(patt1.test('some text'));// OUTPUT:truevar patt2 = new RegExp('ee');console.log(patt2.test('some text'));// OUTPUT:false 1234567891011// 判断是不是QQ号// 1 首位不能是0 ^[1-9]// 2 必须是 [5, 11] 位的数字 \\d&#123;4, 9&#125;var str = '80583600';var regexp = /^[1-9][0-9]&#123;4,10&#125;$/gim;if (regexp.test(str)) &#123; alert('is');&#125; else &#123; alert('no');&#125; exec()exec() 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。 1234567var patt1 = new RegExp('e');console.log(patt1.exec('some text'));// OUTPUT:evar patt2 = new RegExp('ee');console.log(patt2.exec('some text'));// OUTPUT:null compile()compile() 既可以改变检索模式，也可以添加或删除第二个参数。 123456var patt1=new RegExp(\"e\");document.write(patt1.test(\"The best things in life are free\")); // true// 改变了检索模式patt1.compile(\"eee\");document.write(patt1.test(\"The best things in life are free\")); // false 支持正则表达式的 String 对象的方法search 检索与正则表达式相匹配的值。123var str = \"Visit W3School!\"console.log(str.search(/W3School/))// OUTPUT:6 match 找到一个或多个正则表达式的匹配。123var str=\"1 plus 2 equal 3\"console.log(str.match(/\\d+/g))// OUTPUT:1,2,3 replace 替换与正则表达式匹配的子串。123var str = \"Visit Microsoft!\"console.log(str.replace(/Microsoft/, \"W3School\"));// OUTPUT:Visit W3School! 12345678910111213141516171819202122232425262728293031323334// 找重复项最多的字符个数var str = 'g21ss4aeba_ersb43sgnnsssstht6sss60snnsj8resw0_ss';// split : 将字符串转化为数组// sort : 对数组排序，ASCII// join : 将数组转化为字符串var str_new = str.split('').sort().join('');document.write(str + '&lt;br&gt;');document.write(str.split('') + '&lt;br&gt;');document.write(str.split('').sort() + '&lt;br&gt;');document.write(str.split('').sort().join('') + '&lt;br&gt;');// 匹配字符，且重复这个字符，重复次数至少一次。var regexp = /(\\w)\\1+/g;var index = 0;var value = '';str_new.replace(regexp, function($0, $1) &#123; // document.write($0); // document.write($1); if (index &lt; $0.length) &#123; index = $0.length; value = $1; &#125;&#125;);document.write('重复项最多的字符是：' + value + '，个数是：' + index);// OUTPUT:// 0012344668__aabbeeegghjnnnnrrssssssssssssssssttw// 重复项最多的字符是：s，个数是：16 split 把字符串分割为字符串数组。123var str = \"How are you doing today?\"document.write(str.split(/\\s+/));// OUTPUT:How,are,you,doing,today? 经验： 检验格式（邮箱格式、IP格式）是否正确，用test() 抓取星期（如所有手机号），用exec()、match() 替换敏感词汇，用replace() 常见的 正则表达式 校验123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155// 常见的 正则表达式 校验// QQ号、手机号、Email、是否是数字、去掉前后空格、是否存在中文、邮编、身份证、URL、日期格式、IPvar myRegExp = &#123; // 检查字符串是否为合法QQ号码 isQQ: function(str) &#123; // 1 首位不能是0 ^[1-9] // 2 必须是 [5, 11] 位的数字 \\d&#123;4, 9&#125; var reg = /^[1-9][0-9]&#123;4,9&#125;$/gim; if (reg.test(str)) &#123; console.log('QQ号码格式输入正确'); return true; &#125; else &#123; console.log('请输入正确格式的QQ号码'); return false; &#125; &#125;, // 检查字符串是否为合法手机号码 isPhone: function(str) &#123; var reg = /^(0|86|17951)?(13[0-9]|15[012356789]|18[0-9]|14[57]|17[678])[0-9]&#123;8&#125;$/; if (reg.test(str)) &#123; console.log('手机号码格式输入正确'); return true; &#125; else &#123; console.log('请输入正确格式的手机号码'); return false; &#125; &#125;, // 检查字符串是否为合法Email地址 isEmail: function(str) &#123; var reg = /^\\w+((-\\w+)|(\\.\\w+))*\\@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$/; // var reg = /\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*/; if (reg.test(str)) &#123; console.log('Email格式输入正确'); return true; &#125; else &#123; console.log('请输入正确格式的Email'); return false; &#125; &#125;, // 检查字符串是否是数字 isNumber: function(str) &#123; var reg = /^\\d+$/; if (reg.test(str)) &#123; console.log(str + '是数字'); return true; &#125; else &#123; console.log(str + '不是数字'); return false; &#125; &#125;, // 去掉前后空格 trim: function(str) &#123; var reg = /^\\s+|\\s+$/g; return str.replace(reg, ''); &#125;, // 检查字符串是否存在中文 isChinese: function(str) &#123; var reg = /[\\u4e00-\\u9fa5]/gm; if (reg.test(str)) &#123; console.log(str + ' 中存在中文'); return true; &#125; else &#123; console.log(str + ' 中不存在中文'); return false; &#125; &#125;, // 检查字符串是否为合法邮政编码 isPostcode: function(str) &#123; // 起始数字不能为0，然后是5个数字 [1-9]\\d&#123;5&#125; var reg = /^[1-9]\\d&#123;5&#125;$/g; // var reg = /^[1-9]\\d&#123;5&#125;(?!\\d)$/; if (reg.test(str)) &#123; console.log(str + ' 是合法的邮编格式'); return true; &#125; else &#123; console.log(str + ' 是不合法的邮编格式'); return false; &#125; &#125;, // 检查字符串是否为合法身份证号码 isIDcard: function(str) &#123; var reg = /^(^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$)|(^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])((\\d&#123;4&#125;)|\\d&#123;3&#125;[Xx])$)$/; if (reg.test(str)) &#123; console.log(str + ' 是合法的身份证号码'); return true; &#125; else &#123; console.log(str + ' 是不合法的身份证号码'); return false; &#125; &#125;, // 检查字符串是否为合法URL isURL: function(str) &#123; var reg = /^https?:\\/\\/(([a-zA-Z0-9_-])+(\\.)?)*(:\\d+)?(\\/((\\.)?(\\?)?=?&amp;?[a-zA-Z0-9_-](\\?)?)*)*$/i; if (reg.test(str)) &#123; console.log(str + ' 是合法的URL'); return true; &#125; else &#123; console.log(str + ' 是不合法的URL'); return false; &#125; &#125;, // 检查字符串是否为合法日期格式 yyyy-mm-dd isDate: function(str) &#123; var reg = /^[1-2][0-9][0-9][0-9]-[0-1]&#123;0,1&#125;[0-9]-[0-3]&#123;0,1&#125;[0-9]$/; if (reg.test(str)) &#123; console.log(str + ' 是合法的日期格式'); return true; &#125; else &#123; console.log(str + ' 是不合法的日期格式，yyyy-mm-dd'); return false; &#125; &#125;, // 检查字符串是否为合法IP地址 isIP: function(str) &#123; // 1.1.1.1 四段 [0 , 255] // 第一段不能为0 // 每个段不能以0开头 // // 本机IP: 58.50.120.18 湖北省荆州市 电信 var reg = /^([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))&#123;3&#125;$/gi; if (reg.test(str)) &#123; console.log(str + ' 是合法的IP地址'); return true; &#125; else &#123; console.log(str + ' 是不合法的IP地址'); return false; &#125; &#125;&#125;// 测试// console.log(myRegExp.isQQ('80583600'));// console.log(myRegExp.isPhone('17607160722'));// console.log(myRegExp.isEmail('80583600@qq.com'));// console.log(myRegExp.isNumber('100a'));// console.log(myRegExp.trim(' 100 '));// console.log(myRegExp.isChinese('baixiaoming'));// console.log(myRegExp.isChinese('小明'));// console.log(myRegExp.isPostcode('412345'));// console.log(myRegExp.isIDcard('42091119940927001X'));// console.log(myRegExp.isURL('https://www.baidu.com/'));// console.log(myRegExp.isDate('2017-4-4'));// console.log(myRegExp.isIP('1.0.0.0')); 一、校验数字的表达式12345678910111213141516171819数字：^[0-9]*$n位的数字：^\\d&#123;n&#125;$至少n位的数字：^\\d&#123;n,&#125;$m-n位的数字：^\\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$非零的负整数：^\\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\\d*$非负整数：^\\d+$ 或 ^[1-9]\\d*|0$非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式1234567891011汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$长度为3-20的所有字符：^.&#123;3,20&#125;$由26个英文字母组成的字符串：^[A-Za-z]+$由26个大写英文字母组成的字符串：^[A-Z]+$由26个小写英文字母组成的字符串：^[a-z]+$由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$可以输入含有^%&amp;&apos;,;=?$\\&quot;等字符：[^%&amp;&apos;,;=?$\\x22]+禁止输入含有~的字符：[^~\\x22]+ 三、特殊需求表达式123456789101112131415161718192021222324Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;身份证号(15位、18位数字)：^\\d&#123;15&#125;|\\d&#123;18&#125;$短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$中文字符的正则表达式：[\\u4e00-\\u9fa5]双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d) (中国邮政编码为6位数字)IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 钱的输入格式： 1234567891.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里",
		"categories": [],
		"tags": [{
			"name": "RegExp",
			"slug": "RegExp",
			"permalink": "http://www.lovebxm.com/tags/RegExp/"
		}, {
			"name": "正则表达式",
			"slug": "正则表达式",
			"permalink": "http://www.lovebxm.com/tags/正则表达式/"
		}, {
			"name": "正则验证",
			"slug": "正则验证",
			"permalink": "http://www.lovebxm.com/tags/正则验证/"
		}]
	}, {
		"title": "PHP cookie 与 session",
		"slug": "PHP_Cookie_Session",
		"date": "2017-05-30T15:41:23.271Z",
		"updated": "2017-05-30T15:47:03.415Z",
		"comments": true,
		"path": "2017/05/30/PHP_Cookie_Session/",
		"link": "",
		"permalink": "http://www.lovebxm.com/2017/05/30/PHP_Cookie_Session/",
		"excerpt": "PHP 脚本在服务器上执行，然后向浏览器发送回纯 HTML 结果。",
		"text": "PHP 脚本在服务器上执行，然后向浏览器发送回纯 HTML 结果。 PHP 简介 PHP 原为 Personal Home Page 的缩写，已经正式更名为 “PHP: Hypertext Preprocessor“。注意不是“Hypertext Preprocessor”的缩写，这种将名称放到定义中的写法被称作递归缩写。 PHP 是一种==开源的、免费的、跨平台的、面向对象的==服务器端脚本语言 语法吸收了C语言、Java和Perl的特点，主要适用于Web开发领域。 PHP 兼容几乎所有服务器（Apache, IIS 等等） PHP 支持多种数据库 PHP 版本 link查看 PHP 版本123&lt;?php phpinfo();?&gt; PHP的大版本主要分三支：PHP4/PHP5/PHP6 其中，PHP4由于太古老、对QQ支持不力已基本被淘汰，请无视PHP4。 PHP6由于基本没有生产线上的应用，还基本只是一款概念产品，很多功能已在PHP5.3.3上实现，所以也不详述，请无视PHP6。 PHP5的版本主要分四支：PHP5.2之前的版本、PHP5.2.X、PHP5.3和日前发布的PHP5.4。 PHP5.2之前的版本不值得考虑，因为某些功能缺陷或者BUG。 PHP5.4还处于Beta试用的版本号，非稳定版本，请无视PHP5.4。 除了版本号的不同，同一版本号的PHP版本也有区别，并且在选择PHP扩展的时候需要注意。 install版：可执行的MSI格式安装包。 ZIP版：解压即可用。和install版无区别。建议选择ZIP版。 DEBUG版：最终用户无需关心。 版本号 发布时间 内容 PHP 1 1995年 称为 PHP/FI。提供了访客留言本、访客计数器等简单的功能。 PHP 2 1995年6月8日 称为 PHP/FI。已经有 PHP 的一些雏型，像是类似 Perl的变量命名方式、表单处理功能、以及嵌入到 HTML 中执行的能力。 PHP 3 1998年6月 更名为PHP：Hypertext Preprocessor。几乎支持所有主流与非主流数据库。 PHP 4 2000年5月22日 以Zend Engine 1.0为基础，PHP 的核心：Zend Engine PHP 5 2004年7月13日 使用了第二代的Zend Engine 2，包含了许多新特色，如强化的面向对象功能 PHP 5.5.0 2013年6月20日 此版本包含了大量的新功能和bug修复。需要开发者特别注意的一点是不再支持 Windows XP 和 2003 系统。 PHP 6 开发正在进行中 PHP6由于基本没有生产线上的应用，还基本只是一款概念产品，很多功能已在PHP5.3.3上实现，所以也不详述，请无视PHP6。 PHP 开发工具 Zend Studio：商业版，Zend官方出品，基于eclipse Eclipse with PDT：免费 Coda：商业版，针对Mac用户 NetBeans：免费，功能强大 PHP Storm：商业版 Aptana Studio：免费 PhpEd：商业版 Komodo IDE/Edit：IDE为商业版，Edit可免费使用 Adobe Dreamweaver：商业版 cookie / session 机制详解：http://blog.csdn.net/fangaoxin/article/details/6952954 cookie 是存储在客户端浏览器中的数据，通过 Cookie 来跟踪与存储用户数据，常用于识别用户。 session 是将用户的会话数据存储在服务端，没有大小限制。 cookie 简介cookie 是由服务器发送到浏览器的变量。 一般情况下，Cookie通过HTTP headers从服务端返回到客户端。多数web程序都支持Cookie的操作，因为Cookie是存在于HTTP的标头之中，所以必须在其他信息输出以前进行设置，类似于header函数的使用限制。 PHP中的Cookie具有非常广泛的使用，经常用来存储用户的登录信息，购物车等，且在使用会话Session时通常使用Cookie来存储会话id来识别用户，Cookie具备有效期，当有效期结束之后，Cookie会自动的从客户端删除。同时为了进行安全控制，Cookie还可以设置域跟路径。12345678910111213141516// 设置 cookiesetcookie(\"myName\", \"白小明\", time() + 3600);// header(\"Set-Cookie:myName=白小明\");// 获取 cookieif (isset($_COOKIE[\"myName\"])) &#123; echo \"Welcome \" . $_COOKIE[\"myName\"] . \"!&lt;br&gt;\";&#125;else &#123; echo \"Welcome guest!&lt;br&gt;\";&#125;print_r($_COOKIE);// 删除 cookiesetcookie(\"myName\", \"\", time() - 1);// header(\"Set-Cookie:myName=白小明; expires=\".gmdate('D, d M Y H:i:s \\G\\M\\T', time()-1)); setcookie()setcookie() 函数用于设置 cookie。 注释：setcookie() 函数必须位于 标签之前。 1setcookie(\"myName\", \"白小明\", time() + 3600); setrawcookie()PHP 中还有一个设置 Cookie 的函数 setrawcookie() 在发送 cookie 时，cookie 的值会自动进行 URL 编码，在取回时进行自动解码（为防止 URL 编码，请使用 setrawcookie() 取而代之）。 1setrawcookie('cookie_name', rawurlencode($value), time()+60*60*24*365); header()因为Cookie是通过HTTP标头进行设置的，所以也可以直接使用header方法进行设置。 1header(&quot;Set-Cookie:cookie_name=value&quot;); $_COOKIE任何从浏览器发回的Cookie，PHP都会自动的将他存储在 $_COOKIE 的全局变量之中，因此我们可以通过 $_COOKIE[‘key’] 的形式来读取某个Cookie值。如：可以通过 $_COOKIE[“user”] 来访问名为 “user” 的 cookie 的值。 123echo $_COOKIE[&quot;myName&quot;];print_r($_COOKIE); 删除 cookie在PHP中删除cookie也是采用 setcookie 函数来实现。 原理：将cookie的过期时间设置到当前时间之前，则该cookie会自动失效，也就达到了删除cookie的目的。1setcookie(&apos;test&apos;, &apos;&apos;, time()-1); 也可以直接通过header来删除cookie。1header(&quot;Set-Cookie:test=1393832059; expires=&quot;.gmdate(&apos;D, d M Y H:i:s \\G\\M\\T&apos;, time()-1)); cookie 的有效路径cookie 中的路径用来控制设置的cookie在哪个路径下有效，默认为’/‘，在所有路径下都有。12// 使test在/path以及子路径/path/abc下都有效，但是在根目录下就读取不到test的cookie值。setcookie('CookieName', 'CookieValue', time() + 3600, '/path'); session与cookie的异同 cookie 不安全，容易被盗用导致cookie欺骗 单个cookie的值最大只能存储4k，每次请求都要进行网络传输，占用带宽 用户信息既可以存储在sessioin中，也可以存储在cookie中，他们之间的差别在于session可以方便的存取多种数据类型，而cookie只支持字符串类型。 对于一些安全性比较高的数据，cookie需要进行格式化与加密存储，而session存储在服务端则安全性较高。 session 简介会话信息是临时的，在用户离开网站后将被删除。如果您需要永久储存信息，可以把数据存储在数据库中。 session 的工作机制是：为每个访问者创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，亦或通过 URL 进行传导。 123456789101112131415161718192021222324// 启动会话，同时为用户会话分配一个 UID。session_start();// 设置 session// $_SESSION['sessionName'] = 'sessionValue';$_SESSION['ary'] = array('name' =&gt; 'jobs');$_SESSION['obj'] = new stdClass();echo \"session_id:\" . session_id() . \"&lt;br&gt;\";if(isset($_SESSION['sessionName']))&#123; $_SESSION['sessionName'] += 1;&#125; else &#123; $_SESSION['sessionName'] = 1;&#125;// 获取 sessionecho \"sessionName:\" . $_SESSION['sessionName'];var_dump($_SESSION);// 删除 sessionunset($_SESSION['sessionName']);unset($_SESSION['ary']);unset($_SESSION['obj']);// session_destroy(); session_start()session_start() 函数用于启动会话，且必须位于 标签之前。 $_SESSION存储和取回 session 变量的正确方法是使用 $_SESSION 变量 删除 session如果您希望删除某些 session 数据，可以使用 unset() 或 session_destroy() 函数。 unset() 函数用于释放指定的 session 变量，删除某个session值可以使用 unset() 函数 session_destroy() 将重置 session，您将失去所有已存储的 session 数据，如果要删除所有的session，可以使用 session_destroy() 函数，但是 session_id 仍然存在。 注释：如果需要销毁session_id，通常在用户退出的时候可能会用到，则还需要显式的调用setcookie方法删除session_id的cookie值。 注释：session_destroy() 并不会立即的销毁全局变量$_SESSION中的值，只有当下次再访问的时候，$_SESSION才为空，因此如果需要立即销毁$_SESSION，可以使用unset函数。 存储用户的登录信息 - cookie加解密12345678910111213141516171819202122232425262728293031session_start();//假设用户登录成功获得了以下用户数据$userinfo = array( 'uid' =&gt; 10000, 'name' =&gt; 'spark', 'email' =&gt; 'spark@qq.com', 'sex' =&gt; 'man', 'age' =&gt; '18');header(\"content-type:text/html; charset=utf-8\");// 将用户信息保存到session中$_SESSION['userinfo'] = $userinfo;print_r($_SESSION);// 将用户数据保存到cookie中的一个简单方法 -- 加密$secureKey = 'imooc'; //加密密钥$str = serialize($userinfo); //将用户信息序列化$str = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), $str, MCRYPT_MODE_ECB));echo \"加密后的用户信息：\";print_r($str);//将加密后的用户数据存储到cookie中setcookie('userinfo', $str);// 当需要使用时进行 -- 解密$str = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), base64_decode($str), MCRYPT_MODE_ECB);$uinfo = unserialize($str);echo \"解密后的用户信息：\";print_r($uinfo);",
		"categories": [],
		"tags": [{
			"name": "PHP",
			"slug": "PHP",
			"permalink": "http://www.lovebxm.com/tags/PHP/"
		}, {
			"name": "cookie",
			"slug": "cookie",
			"permalink": "http://www.lovebxm.com/tags/cookie/"
		}, {
			"name": "session",
			"slug": "session",
			"permalink": "http://www.lovebxm.com/tags/session/"
		}]
	}, {
		"title": "MySQL 安装（Windows）及常用命令",
		"slug": "mysqlCommon",
		"date": "2017-05-30T15:37:08.339Z",
		"updated": "2017-05-30T15:43:34.738Z",
		"comments": true,
		"path": "2017/05/30/mysqlCommon/",
		"link": "",
		"permalink": "http://www.lovebxm.com/2017/05/30/mysqlCommon/",
		"excerpt": "MySQL 简介 MySQL 由瑞典MySQL AB公司开发，目前被oracle公司收购。 开源、关系型数据库管理系统 MySQL所使用的SQL语言是用于访问数据库的最常用标准化语言。 版本分为【社区版】和【企业版（商业版）】 LAMP 环境：Linux + Apache + MySQL + PHP，一组常用来搭建动态网站或者服务器的开源软件 官网及下载地址：https://www.mysql.com/",
		"text": "MySQL 简介 MySQL 由瑞典MySQL AB公司开发，目前被oracle公司收购。 开源、关系型数据库管理系统 MySQL所使用的SQL语言是用于访问数据库的最常用标准化语言。 版本分为【社区版】和【企业版（商业版）】 LAMP 环境：Linux + Apache + MySQL + PHP，一组常用来搭建动态网站或者服务器的开源软件 官网及下载地址：https://www.mysql.com/ MySQL 语法规则 关键字与函数名称全部大写 数据库名称、表名称、字段名称全部小写 SQL 语句必须以分号结尾 MySQL 安装安装方式分为：MSI安装（Windows installer）、ZIP安装 下载之前需要登录 百度经验 MySQL 配置在 cmd 中输入 mysql，提示【’mysql’ 不是内部或外部命令，也不是可运行的程序或批处理文件】 只需将MySQL安装路径添加系统环境变量即可。 环境变量中编辑系统变量Path，添加如下路径，最后，在 cmd 中输入 mysql 检测。 1;C:\\Program Files\\MySQL\\MySQL Server 5.7\\bin mysql ERROR 1045 (28000): 错误解决办法 启动 / 关闭 MySQL 服务以管理员身份运行cmd、也可以在任务管理器中开启/关闭服务12345678C:\\Windows\\system32&gt;net start mysql57MySQL57 服务正在启动 .MySQL57 服务已经启动成功。C:\\Windows\\system32&gt;net stop mysql57MySQL57 服务正在停止.MySQL57 服务已成功停止。 进入 MySQL12345678910111213C:\\Users\\bxm09&gt;mysql -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 14Server version: 5.7.18-log MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement. 退出 MySQL下面的三个命令都可以12345mysql&gt; exit;mysql&gt; quit;mysql&gt; \\q;Bye 修改MySQL提示符1234567mysql&gt; prompt bxm&gt;PROMPT set to &apos;bxm&gt;&apos;bxm&gt;mysql&gt; prompt \\DPROMPT set to &apos;\\D&apos;Wed Apr 26 14:18:39 2017 查看 MySQL 版本信息123456789101112131415161718192021mysql&gt; status--------------mysql Ver 14.14 Distrib 5.7.18, for Win64 (x86_64)Connection id: 11Current database:Current user: ODBC@SSL: Not in useUsing delimiter: ;Server version: 5.7.18-log MySQL Community Server (GPL)Protocol version: 10Connection: localhost via TCP/IPServer characterset: utf8Db characterset: utf8Client characterset: gbkConn. characterset: gbkTCP port: 3306Uptime: 41 min 32 secThreads: 1 Questions: 24 Slow queries: 0 Opens: 100 Flush tables: 1 Open tables: 95 Queries per second avg: 0.009-------------- 显示服务器当前版本1234567mysql&gt; SELECT VERSION();+------------+| VERSION() |+------------+| 5.7.18-log |+------------+1 row in set (0.00 sec) 显示服务器当前时间1234567mysql&gt; SELECT NOW();+---------------------+| NOW() |+---------------------+| 2017-04-26 14:26:07 |+---------------------+1 row in set (0.00 sec) 显示当前用户1234567mysql&gt; SELECT USER();+--------+| USER() |+--------+| ODBC@ |+--------+1 row in set (0.00 sec) 创建数据库1CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset_name; 12345mysql&gt; CREATE DATABASE demo1;Query OK, 1 row affected (0.00 sec)mysql&gt; CREATE DATABASE IF NOT EXISTS demo1;Query OK, 1 row affected, 1 warning (0.00 sec) 查看警告信息1234567mysql&gt; SHOW WARNINGS;+-------+------+------------------------------------------------+| Level | Code | Message |+-------+------+------------------------------------------------+| Note | 1007 | Can&apos;t create database &apos;demo1&apos;; database exists |+-------+------+------------------------------------------------+1 row in set (0.00 sec) 显示数据库列表12345678910111213mysql&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || demo1 || mysql || performance_schema || sakila || sys || world |+--------------------+7 rows in set (0.00 sec) 显示表1234567891011mysql&gt; SHOW TABLES;+---------------------+| Tables_in_shopimooc |+---------------------+| imooc_admin || imooc_album || imooc_cate || imooc_pro || imooc_user |+---------------------+5 rows in set (0.00 sec) 查看表结构123456789101112mysql&gt; use shopImoocDatabase changedmysql&gt; desc imooc_admin;+----------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || username | varchar(30) | NO | UNI | NULL | || password | char(32) | NO | | NULL | || email | varchar(60) | NO | | NULL | |+----------+------------------+------+-----+---------+----------------+4 rows in set (0.00 sec) 查看表内容123456789mysql&gt; select * from imooc_admin;+----+----------+----------------------------------+-----------------+| id | username | password | email |+----+----------+----------------------------------+-----------------+| 1 | king | b2086154f101464aab3328ba7e060deb | 80583600@qq,com || 2 | admin | admin | admin@qq.com || 3 | bxm | bxm | bxm@qq.com |+----+----------+----------------------------------+-----------------+3 rows in set (0.00 sec) 修改数据库1ALTER &#123;DATABASE | SCHEMA&#125; db_name [DEFAULT] CHARACTER SET [=] charset_name; 12345678910mysql&gt; ALTER DATABASE demo1 CHARACTER SET gbk;Query OK, 1 row affected (0.01 sec)mysql&gt; SHOW CREATE DATABASE demo1;+----------+---------------------------------------------------------------+| Database | Create Database |+----------+---------------------------------------------------------------+| demo1 | CREATE DATABASE `demo1` /*!40100 DEFAULT CHARACTER SET gbk */ |+----------+---------------------------------------------------------------+1 row in set (0.00 sec) 删除数据库1DROP &#123;DATABASE | SCHEMA&#125; [IF EXISTS] db_name; 12mysql&gt; DROP DATABASE demo1;Query OK, 0 rows affected (0.02 sec)",
		"categories": [],
		"tags": [{
			"name": "MySQL",
			"slug": "MySQL",
			"permalink": "http://www.lovebxm.com/tags/MySQL/"
		}, {
			"name": "MySQL 增删改查",
			"slug": "MySQL-增删改查",
			"permalink": "http://www.lovebxm.com/tags/MySQL-增删改查/"
		}]
	}, {
		"title": "网站性能优化（Yahoo军规）",
		"slug": "WPO",
		"date": "2017-05-30T09:35:20.819Z",
		"updated": "2017-05-30T09:47:44.240Z",
		"comments": true,
		"path": "2017/05/30/WPO/",
		"link": "",
		"permalink": "http://www.lovebxm.com/2017/05/30/WPO/",
		"excerpt": "压缩 HTML、CSS、JS代码压缩技术可以从文件中去掉多余的字符。你在编辑器中写代码的时候，会使用缩进和注释，这些方法会让你的代码简洁而且易读，但它们也会在文档中添加多余的字节。 使用压缩工具可以非常简单地把无用的字节从你的 CSS、JS 和 HTML 文件修剪掉。一般使用工具进行压缩 Gzip、Brotli chrome控制台检查js代码，有个小小的“{}”符号，可以将压缩的代码格式化（format），还挺好用的。 image",
		"text": "压缩 HTML、CSS、JS代码压缩技术可以从文件中去掉多余的字符。你在编辑器中写代码的时候，会使用缩进和注释，这些方法会让你的代码简洁而且易读，但它们也会在文档中添加多余的字节。 使用压缩工具可以非常简单地把无用的字节从你的 CSS、JS 和 HTML 文件修剪掉。一般使用工具进行压缩 Gzip、Brotli chrome控制台检查js代码，有个小小的“{}”符号，可以将压缩的代码格式化（format），还挺好用的。 image 正确放置 CSS （页面上面）避免页面空白或闪烁。 把 CSS 放在 HTML 的上面部分，文档头之内，这可以确保正常的渲染过程。 这个策略不能提高网站的加载速度，但它不会让访问者长时间看着空白屏幕或者无格式的文本（FOUT）等待。如果网页大部分可见元素已经加载出来了，访问者才更有可能等待加载整个页面，从而带来对前端的优化效果。这就是知觉性能。 此外，不少网站管理员在网页中错误的使用 @import指令 来引入外部样式表。这是一个过时的方法，它会阻止浏览并行下载。link 标签才是最好的选择，它也能提高网站的前端性能。多说一句，通过 link 标签请求加载的外部样式表不会阻止并行下载。 正确放置 Javascript （页面下面）如果将 JavaScript 放置在 head 标签内或 HTML 文档的上部，这会阻塞 HTML 和 CSS 元素的加载过程。这个错误会导致页面加载时间增长，增加用户等待时间，容易让人感到不耐烦而放弃对网站的访问。 可以将JavaScript属性置于HTML底部来避免此问题。 启用 Gzip 压缩 使用预先获取link 预先获取可以在真正需要之前通过取得必需的资源和相关数据来改善访问用户的浏览体验，主要有3类预先获取:链接预先获取、DNS 预先获取、预先渲染,在 HTML 中的链接属性上增加 rel=”prefetch”、rel=”dns-prefetch”或者 rel=”prerender” 标记。链接预先获取：在HTML5中,有个很有用但常被忽略的特性，就是预先加载(prefetch)，它的原理是：利用浏览器的空闲时间去先下载用户指定需要的内容，然后缓存起来，这样用户下次加载时，就直接从缓存中取出来，效率就快了。 12&lt;link rel=\"prerender\" href=\"http://www.example.com/\"&gt; &lt;!-Chrome --&gt;&lt;link rel=\"prefetch\" href=\"http://www.example.com/\"&gt; &lt;!-Firefox --&gt; 即使在不支持的浏览器,用了这个特性其实是不会出错的,只不过浏览器解析不到而已。如果你感觉能有办法预先预测到用户期望点的页面(比如用户看最新的受欢迎的热图,他 可能看了第一页后,会继续看下一页)，这个时候就可以用预先加载这个特性了。比如 12&lt;link rel=\"prefetch\" href=\"/images/test.jpg\"/&gt; &lt;!-取图片 --&gt;&lt;link rel=\"prefetch\" href=\"&lt;?php echo get_next_posts_page_link(); ?&gt;\"&gt; 使用 CDNCDN的全称是Content Delivery Network，即内容分发网络，内容分发网络能显著提高网站的速度和性能。 减少DOM操作次数JS 少用全局变量，缓存DOM节点查找的结果尽可能的减少 HTTP 请求数 避免使用CSS Expressions （CSS 表达式）CSS表达式（CSS Expression），又称动态属性（Dynamic properties）。 在页面显示或缩放、鼠标移动、页面滚动的时候，css表达式都会重新计算一次，严重影响网页性能。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; ul a &#123; /* IE 6 7 8 */ width: expression(this.offsetWidth &gt; 750? add() : add()); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;Lorem ipsum dolor sit amet.&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Lorem ipsum dolor sit amet.&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Lorem ipsum dolor sit amet.&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;当鼠标移动时，CSS 表达式计算了&lt;b id=\"run\"&gt;&lt;/b&gt;次&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; var i = 0; function add() &#123; i++; document.getElementById('run').innerHTML = i; return; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 把js和css都写在外部文件中（酌情）CSS、JS写在页面内的情况： 只应用于一个页面。 不经常被访问到。 脚本和样式很少（20行以下时）。 减少 DNS 查询DNS（Domain Name System，域名系统） 通过DNS查找到域名对应的ip地址，一次大约60ms 避免重定向无论是通过服务器端重定向还是通过JavaScript代码进行内容重定向，网站都会首先加载一个空白的页面，然后再定向到另外的页面，这样不仅延长了页面的加载时间，还很有可能导致无法跳转，让用户面对一个“空白”页面。 定义：原始请求被重新转到了其他请求 301：被移动到另外位置（永久重定向）使搜索引擎智能,不需要从旧地址到新地址，删除旧地址，直接到新地址 302：页面被找到，但不在原始位置（临时重定向）先到旧地址，再到新地址 重定向：重新请求下载资源，增加了http请求 移除重复的脚本重复引用的脚本，会执行多次 配置实体标签 ETags使用一种标志表示一种资源是否做了修改，可以减少服务器的响应。 详细点就是：浏览器想服务器要某种资源，服务器一看，判断出了这种资源已经给过浏览器了，并且在服务器端的也没有变化，所以浏览器可以使用他自身就有的，然后告诉浏览器，浏览器回到自身找找，找到啦就用了，这样浏览器和服务器之间会有对话不过不用服务器再重复的给浏览器资源了！ 使 AJAX 缓存AJAX 可使页面局部异步更新。 get 同一地址不重复执行，可以被缓存 post 不会被缓存，每次都会传送到服务器那里，一般返回200； 添加 Expire/Cache-Control 头",
		"categories": [],
		"tags": [{
			"name": "WPO",
			"slug": "WPO",
			"permalink": "http://www.lovebxm.com/tags/WPO/"
		}, {
			"name": "网站性能优化",
			"slug": "网站性能优化",
			"permalink": "http://www.lovebxm.com/tags/网站性能优化/"
		}, {
			"name": "Gzip 压缩",
			"slug": "Gzip-压缩",
			"permalink": "http://www.lovebxm.com/tags/Gzip-压缩/"
		}, {
			"name": "CDN",
			"slug": "CDN",
			"permalink": "http://www.lovebxm.com/tags/CDN/"
		}]
	}, {
		"title": "可能是最详细的 Hexo + GitHub Pages 搭建博客的教程",
		"slug": "buildBlog",
		"date": "2017-05-29T16:06:49.991Z",
		"updated": "2017-06-01T01:45:48.768Z",
		"comments": true,
		"path": "2017/05/30/buildBlog/",
		"link": "",
		"permalink": "http://www.lovebxm.com/2017/05/30/buildBlog/",
		"excerpt": "前言：博主目前大三，Web 前端爱好者。写博客的好处，不是为了写而写，而是一个记录思想的过程。不要考虑它能带给你什么，而是你自己从中收获了什么。 最近刚好有空，于是就参照网上的各种教程，搭建了一个博客。现在把 Hexo + GitHub Pages 搭建博客的完整过程记录下来：",
		"text": "前言：博主目前大三，Web 前端爱好者。写博客的好处，不是为了写而写，而是一个记录思想的过程。不要考虑它能带给你什么，而是你自己从中收获了什么。 最近刚好有空，于是就参照网上的各种教程，搭建了一个博客。现在把 Hexo + GitHub Pages 搭建博客的完整过程记录下来： 个人博客地址：http://www.lovebxm.com 大概流程： 搭建 Node.js 环境 搭建 Git 环境 GitHub 注册和配置 安装配置 Hexo 关联 Hexo 与 GitHub Pages GitHub Pages 地址解析到个人域名 Hexo 的常用操作 结束语 搭建 Node.js 环境 为什么要搭建 Node.js 环境？ - 因为 Hexo 博客系统是基于 Node.js 编写的 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。 在 Node.js 官网：https://nodejs.org/en/ 下载安装包 v6.10.3 LTS 保持默认设置即可，一路Next，安装很快就结束了。 然后打开命令提示符，输入 node -v、npm -v，出现版本号则说明 Node.js 环境配置成功，第一步完成！！！ 搭建 Git 环境 为什么要搭建 Git 环境？ - 因为需要把本地的网页和文章等提交到 GitHub 上。 Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 在 Git 官网：https://git-scm.com/ 下载安装包 Git-2.13.0-64-bit.exe 桌面右键，打开 Git Bush Here，输入 git --version，出现版本号则说明 Git 环境配置成功，第二步完成！！！ GitHub 注册和配置GitHub 是一个代码托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。 Github注册：https://github.com/ image 创建仓库：Repository name 使用自己的用户名，仓库名规则： 注意：yourname 必须是你的用户名。 1yourname/yourname.github.io 访问 yourname.github.io，如果可以正常访问，那么 Github 的配置已经结束了。 到此搭建 Hexo 博客的相关环境配置已经完成，下面开始讲解 Hexo 的相关操作 安装配置 HexoHexo 是一个快速、简洁且高效的博客框架，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 强烈建议你花20分钟区读一读 Hexo 的官方文档：https://hexo.io/zh-cn/ 使用 npm 安装 Hexo：在命令行中输入 1npm install hexo-cli -g 然后你将会看到下图，可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 查看Hexo的版本 1hexo version 安装 Hexo 完成后，请执行下列命令来初始化 Hexo，用户名改成你的，Hexo 将会在指定文件夹中新建所需要的文件。 12345hexo init bxm0927.github.iocd bxm0927.github.ionpm install 新建完成后，指定文件夹的目录如下： 1234567891011.├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json #npm 依赖等 运行本地 Hexo 服务 123hexo server或者hexo s 您的网站会在 http://localhost:4000 下启动。如果 http://localhost:4000 能够正常访问，则说明 Hexo 本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。 注意1：执行hexo server提示找不到该指令 解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下： 123sudo npm install hexo-server或者npm install hexo -server --save 关联 Hexo 与 GitHub Pages我们如何让本地git项目与远程的github建立联系呢？用 SSH keys 生成SSH keys 输入你自己的邮箱地址 1ssh-keygen -t rsa -C &quot;80583600@qq.com&quot; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入，我们按回车不设置密码。 添加 SSH Key 到 GitHub 打开 C:\\Users\\bxm09\\.ssh\\id_rsa.pub，此文件里面内容为刚才生成的密钥，准确的复制这个文件的内容，粘贴到 https://github.com/settings/ssh 的 new SSH key 中 测试 可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改： 1ssh -T git@github.com 如果是下面的反馈： The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不要紧张，输入yes就好，然后会看到： 1Hi aierui! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 配置Git个人信息 现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。 12git config --global user.name &quot;bxm0927&quot;git config --global user.email &quot;80583600@qq.com&quot; 配置 Deployment 在_config.yml文件中，找到Deployment，然后按照如下修改，用户名改成你的： 需要注意的是：冒号后面记得空一格！ 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:bxm0927/bxm0927.github.io.git branch: master 本地文件提交到 GitHub Pages 123456789101112// 删除旧的 public 文件hexo clean// 生成新的 public 文件hexo generate或者hexo g// 开始部署hexo deploye或者hexo d 在浏览器中输入 https://bxm0927.github.io （用户名改成你的）看到了 Hexo 与 GitHub Pages 已经成功关联了，哇哇哇哇哇哇，开心死你了，不要忘了回来给我点赞哟 ~ 注意1：若上面操作失败，则需要提前安装一个扩展： 1npm install hexo-deployer-git --save 注意2：如果在执行 hexo d 后,出现 error deployer not found:github 的错误（如下），则是因为没有设置好 public key 所致，重新详细设置即可。 Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 注意3：怎么避免 .md 文件被解析？ Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了 README. md，它也会在你下一次部署时被删去。怎么解决呢？ 在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。 GitHub Pages 地址解析到个人域名 Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服 务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默 认提供的域名 github.io 或者自定义域名来发布站点。 看着博客的域名是二级域名，总有一种寄人篱下的感觉，为了让这个小窝看起来更加正式，我在阿里云上买了一个域名，打算将博客绑定自己的域名。 进行该绑定过程，其实就是一个重定向的过程。 在 GitHub 仓库的根目录下建立一个 CNAME 的文本文件(注意：没有扩展名)，文件里面只能输入一个你的域名，不能加http:// 1www.lovebxm.com 注意：CNAME 一定是在你 Github 项目的 master 根目录下 进入阿里云域名解析地址，添加解析： 记录类型选择CNAME 主机记录填www 解析线路选择默认 记录值填yourname.github.io TTL值为10分钟 再添加一个解析，记录类型A 主机记录填www 解析线路选择默认 记录值填你GitHub 的ip地址（在cmd中ping：） 1ping bxm0927.github.com 点击保存，等 1 分钟，访问下你自己的域名，一切就ok了。 域名绑定成功，域名解析成功，因此你在浏览中输入 www.lovebxm.com，或 lovebxm.com 就可以访问到博客了，输入 bxm0927.github.io 会重定向到 www.lovebxm.com。过程：www 的方式，会先解析成 http://xxxx.github.io，然后根据 CNAME 再变成 www 注意：CNAME文件在下次 hexo deploy的时候就消失了，需要重新创建，这样就很繁琐 方法一：每次 hexo d 之后，就去 GitHub 仓库根目录新建 CNAME文件 方法二：在 hexo g 之后， hexo d 之前，把CNAME文件复制到 “\\public\\” 目录下面，里面写入你要绑定的域名。 方法三（推荐）：将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等，这样在 hexo d 之后就不会被删除了。 方法四：通过安装插件实现永久保留 1$ npm install hexo-generator-cname --save 之后在_config.yml中添加一条 12plugins:- hexo-generator-cname 需要注意的是：如果是在github上建立的CNAME文件，需要先clone到本地，然后安装插件，在deploy上去即可。CNAME只允许一个域名地址。 注意1：每次生成的 CNAME 都是 yoursite.com 怎么解决？ 修改 _config.yml1234url: http://www.lovebxm.comroot: /permalink: :year/:month/:day/:title/permalink_defaults: Hexo 的常用操作发表一篇文章1234hexo new &quot;文章标题&quot;D:\\GitHub\\Hexo\\test&gt;hexo new &quot;文章标题&quot;INFO Created: D:\\GitHub\\Hexo\\test\\source\\_posts\\文章标题.md 在本地博客文件夹 source\\_posts 文件夹下看到我们新建的 markdown 文件。 当然，我们也可以手动添加Markdown文件在source-&gt;_deploy文件夹下，其效果同样可以媲美hexo new 文章编辑好之后，运行生成、部署命令： 12345hexo cleanhexo ghexo d 当然你也可以执行下面的命令，相当于上面两条命令的效果 123hexo cleanhexo d -g 新建一个自定义页面1hexo new page folder ###文章如何添加多个标签 有两种多标签格式 123456tags: [a, b, c]或tags: - a - b - c 显示部分文章内容如果在博客文章列表中，不想全文显示，可以增加 &lt;!-- more --&gt;, 后面的内容就不会显示在列表。 1&lt;!--more--&gt; 更改主题官方主题库：https://hexo.io/themes/ Hexo主题非常，推荐使用 Next 为主题，请阅读 Next 的官方文档（ http://theme-next.iissnan.com/ ），5 分钟快速安装。 再提示一点，大家可以hexo主题修改一步就hexo s看下变化，初次接触对参数不清楚。只有hexo s后在可以在本地浏览到效果，Ctrl+C 停止服务器。 添加插件添加 sitemap 和 feed 插件 切换到你本地的 hexo 目 CIA ，在命令行窗口，输入以下命令 12npm install hexo-generator-feed -savenpm install hexo-generator-sitemap -save 修改 _config.yml，增加以下内容 123456789101112# ExtensionsPlugins:- hexo-generator-feed- hexo-generator-sitemap#Feed Atomfeed: type: atom path: atom.xml limit: 20#sitemapsitemap: path: sitemap.xml 再执行以下命令，部署服务端 1hexo d -g 配完之后，就可以访问 https://bxm0927.github.io/atom.xml 和 https://bxm0927.github.io/sitemap.xml ，发现这两个文件已经成功生成了。 添加 404 页面GitHub Pages 自定义404页面非常容易，直接在根目录下创建自己的404.html就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。 其实，404页面可以做更多有意义的事，来做个404公益项目吧。 推荐使用腾讯公益404 http://www.qq.com/404/ ： 123456&lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;http://www.lovebxm.com/&quot; homePageName=&quot;回到我的主页&quot;&gt;&lt;/script&gt; 复制上面代码，贴粘到目录下新建的404.html即可！ 多PC同步管理博客很多人可能家里一台笔记本，公司一个台式机，想两个同时管理博客，同时达到备份的博客主题、文章、配置的目的。下面就介绍一下用github来备份博客并同步博客。 A电脑备份博客内容到github 配置.gitignore文件。进入博客目录文件夹下，找到此文件，用sublime text 打开，在最后增加两行内容/.deploy_git和/public 初始化仓库。 在博客根目录下，在git bash下依次执行git init和git remote add origin 为远程仓库地址。 同步到远程仓库。 gitbash下依次执行以下命令 12345git add . #添加目录下所有文件git commit -m &quot;更新说明&quot; #提交并添加更新说明git push -u origin master #推送更新到远程仓库 B电脑拉下远程仓库文件 在B电脑上同样先安装好node、git、ssh、hexo，然后建好hexo文件夹，安装好插件，（然后选做：将备份到远程仓库的文件及文件夹删除），然后执行以下命令： 1234567git initgit remote add origin &lt;server&gt;git fetch --allgit reset --hard origin/master 发布博客后同步 在B电脑发布完博客之后，记得将博客备份同步到远程仓库执行以下命令： 1234567git add .#可以用git master 查看更改内容git commit -m &quot;更新信息&quot;git push -u origin master #以后每次提交可以直接git push 平时同步管理每次想写博客时，先执行：git pull进行同步更新。发布完文章后同样按照上面的 发布博客后同步 同步到远程仓库。 中文乱码在 md 文件中写中文内容，发布出来后为乱码，原因是 md 的编码不对，将 md 文件另存为UTF-8编码的文件即可解决问题。 结束语建站的系统有很多，如： Hexo + GitHub Pages Jekyll + GitHub Pages WordPress + 服务器 + 域名 DeDeCMS + 服务器 + 域名 … 使用 Hexo + GitHub Pages 建站，有优点也有缺点： GitHub Pages 不支持数据库管理，所以你只能做静态页面的博客，不能像其他博客（如 WordPress）那样通过数据库管理自己的博客内容。 但是，GitHub Pages 无需购置服务器，免服务器费的同时还能做负载均衡，github pages有300M免费空间。 个人博客真的有必要用数据库吗？答案是否定的。博客静态化，评论记录使用第三方的 网易云跟帖就可以了。静态的博客更有利于搜索引擎蜘蛛爬取，轻量化的感觉真的很好。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，非常符合我的口味。Markdown 真的是专门针对程序员开发的语言啊，现在感觉没有 Markdown什么都不想写。什么富文本编辑器，什么word，太麻烦了！而且样式都好丑！效率太低！ 推荐几个很好用的在线 Markdown 编辑器： 作业部落：https://www.zybuluo.com/mdeditor 马克飞象：https://maxiang.io 推荐图床： 极简图床 + chrome 插件 + 七牛空间，七牛云储存提供10G的免费空间,以及每月10G的流量，存放个人博客外链图片最好不过了，七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力。",
		"categories": [],
		"tags": [{
			"name": "GitHub Pages",
			"slug": "GitHub-Pages",
			"permalink": "http://www.lovebxm.com/tags/GitHub-Pages/"
		}, {
			"name": "Hexo",
			"slug": "Hexo",
			"permalink": "http://www.lovebxm.com/tags/Hexo/"
		}, {
			"name": "Git",
			"slug": "Git",
			"permalink": "http://www.lovebxm.com/tags/Git/"
		}, {
			"name": "Node.js",
			"slug": "Node-js",
			"permalink": "http://www.lovebxm.com/tags/Node-js/"
		}, {
			"name": "博客",
			"slug": "博客",
			"permalink": "http://www.lovebxm.com/tags/博客/"
		}]
	}]
}
